//! This example is used by a python module for benchmarking airs. It offers a CLI to control its
//! behavior and measures time itself to make it easier to exclude parsing times for data.
//! Time is saved to a file in nanoseconds. If multiple times are measured, they are written
//! sequentially with a newline in between.

use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::process::exit;
use std::time::{Duration, Instant};

use clap::{Parser, Subcommand};
use serde::Serialize;

use libairs::ancestors::{AncestorArray, AncestorGenerator};
use libairs::ts::{PartialTreeSequence, ViterbiMatcher};
use libairs::variants::VariantData;

#[derive(Parser)]
#[command(version, arg_required_else_help = true)]
struct CliArgs {
    /// The number of threads to use for parallel processing. Defaults to 1.
    #[arg(short = 't', long = "threads", default_value_t = 1)]
    num_threads: u16,

    /// Where to save the calculated timings to
    #[arg(long)]
    timings: Option<String>,

    #[command(subcommand)]
    command: Action,
}

#[derive(Subcommand)]
enum Action {
    GenerateAncestors {
        /// Variant data file generated by `convert-inputs` or a custom file in the format described
        #[arg(short, long)]
        input: String,

        /// Output path for the .aa file. Optional. Will default to the input path and just change
        /// the file extension.
        #[arg(short, long)]
        output: Option<String>,
    },
    MatchAncestors {
        /// A .aa file generated by a previous call to `generate-ancestors`
        #[arg(short, long)]
        ancestors: String,

        /// Output path for the .aa file. Optional. Will default to the input path and just change
        /// the file extension.
        #[arg(short, long)]
        output: Option<String>,
    },
    MatchSamples {
        /// A .aa file generated by a previous call to `generate-ancestors`
        #[arg(short, long)]
        ancestors: String,

        /// A .pts file generated by a previous call to `match-ancestors`
        #[arg(short, long)]
        trees: String,

        /// Output path for the .pts file. Optional. Will default to the input path and just change
        /// the file extension. If the trees input file has this name already, it will be overwritten.
        #[arg(short, long)]
        output: Option<String>,
    },
    Infer {
        #[arg(short, long)]
        input: String,
    },
}

fn main() {
    let args = CliArgs::parse();

    if args.num_threads > 1 {
        rayon::ThreadPoolBuilder::new()
            .num_threads(args.num_threads as usize)
            .build_global()
            .unwrap();
    }

    let mut timings_file = args.timings.map(|path| {
        File::create_new(&path).unwrap_or_else(|error| {
            eprintln!("could not create timings file at {}: {}", path, error);
            exit(-1);
        })
    });

    match args.command {
        Action::GenerateAncestors { input, output } => {
            let variant_data = parse_input(&input).unwrap_or_else(|error| {
                eprintln!("could not parse input data: {}", error);
                exit(-1);
            });
            let ag = AncestorGenerator::from_variant_data(variant_data);

            let start = Instant::now();
            let ancestors = ag.generate_ancestors();
            let end = start.elapsed();
            write_time(&mut timings_file, end);
            println!("generated {} ancestors in {:?}", ancestors.len(), end);

            write_output(&input, "aa", output, &ancestors);
        }
        Action::MatchAncestors { ancestors, output } => {
            let data = File::open(&ancestors).unwrap_or_else(|error| {
                eprintln!("could not read input file: {}", error);
                exit(-1);
            });
            let ancestor_array: AncestorArray =
                bincode::deserialize_from(&data).unwrap_or_else(|error| {
                    eprintln!("could not deserialize ancestors: {}", error);
                    exit(-1);
                });

            let mut ancestor_matcher = ViterbiMatcher::new(ancestor_array, 1e-2, 1e-20, true, 40);
            let start = Instant::now();
            ancestor_matcher.match_ancestors();
            let end = start.elapsed();
            write_time(&mut timings_file, end);
            println!("matched ancestors in {:?}", end);

            write_output(
                &ancestors,
                "pts",
                output,
                ancestor_matcher.get_partial_tree_sequence(),
            );
        }
        Action::MatchSamples {
            ancestors,
            trees,
            output,
        } => {
            let ancestors_data = File::open(&ancestors).unwrap_or_else(|error| {
                eprintln!("could not read ancestors file: {}", error);
                exit(-1);
            });
            let ancestor_array: AncestorArray = bincode::deserialize_from(&ancestors_data)
                .unwrap_or_else(|error| {
                    eprintln!("could not deserialize ancestors: {}", error);
                    exit(-1);
                });

            let trees_data = File::open(&trees).unwrap_or_else(|error| {
                eprintln!("could not read trees file: {}", error);
                exit(-1);
            });
            let partial_tree_sequence: PartialTreeSequence = bincode::deserialize_from(&trees_data)
                .unwrap_or_else(|error| {
                    eprintln!("could not deserialize partial tree sequence: {}", error);
                    exit(-1);
                });

            let mut ancestor_matcher = ViterbiMatcher::new(ancestor_array, 1e-2, 1e-20, true, 40);
            ancestor_matcher.read_partial_tree_sequence(partial_tree_sequence);
            let start = Instant::now();
            ancestor_matcher.match_samples();
            let end = start.elapsed();
            write_time(&mut timings_file, end);
            println!("matched samples in {:?}", end);

            write_output(
                &ancestors,
                "pts",
                output,
                &ancestor_matcher.get_partial_tree_sequence(),
            );
        }
        Action::Infer { input } => {
            let variant_data = parse_input(&input).unwrap_or_else(|error| {
                eprintln!("could not parse input data: {}", error);
                exit(-1);
            });
            let ag = AncestorGenerator::from_variant_data(variant_data);

            let mut total = Duration::new(0, 0);

            let start = Instant::now();
            let ancestors = ag.generate_ancestors();
            let end = start.elapsed();
            total += end;
            write_time(&mut timings_file, end);
            println!("generated {} ancestors in {:?}", ancestors.len(), end);

            let start = Instant::now();
            let mut ancestor_matcher =
                libairs::ts::ViterbiMatcher::new(ancestors, 1e-2, 1e-20, true, 40);
            ancestor_matcher.match_ancestors();
            let end = start.elapsed();
            total += end;
            write_time(&mut timings_file, end);
            println!("matched ancestors in {:?}", end);

            let start = Instant::now();
            ancestor_matcher.match_samples();
            let end = start.elapsed();
            total += end;
            write_time(&mut timings_file, end);
            println!("matched samples in {:?}", end);

            println!("total time: {:?}", total);
        }
    }
}

/// Write a time to a file if the file exists
fn write_time(file: &mut Option<File>, time: Duration) {
    if let Some(f) = file.as_mut() {
        writeln!(f, "{}", time.as_nanos()).unwrap_or_else(|error| {
            eprintln!("could not write to timings file: {}", error);
            exit(-1);
        });
    }
}

fn parse_input(variant_data: &str) -> anyhow::Result<VariantData> {
    Ok(bincode::deserialize_from(File::open(variant_data)?)?)
}

/// Write a serializable data structure to the optional output path or to the input path with the
/// provided extension.
fn write_output(
    input_path: &String,
    extension: &str,
    output: Option<String>,
    data: &impl Serialize,
) {
    let output_path = if let Some(path) = output {
        path
    } else {
        let mut buf = PathBuf::from(input_path);
        buf.set_extension(extension);
        String::from(buf.to_str().unwrap())
    };

    let serialized = bincode::serialize(&data).unwrap();
    File::create(output_path)
        .unwrap_or_else(|error| {
            eprintln!("could not create output file: {}", error);
            exit(-1);
        })
        .write_all(&serialized)
        .unwrap_or_else(|error| {
            eprintln!("could not write to output file: {}", error);
            exit(-1);
        });
}
